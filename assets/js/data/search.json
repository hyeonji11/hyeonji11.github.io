[ { "title": "AOP", "url": "/posts/AOP/", "categories": "Spring, AOP", "tags": "AOP", "date": "2022-06-22 16:10:00 +0800", "snippet": "AOPAOP란?Aspect Oriented Programming, **관점 지향 프로그래밍어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것.핵심적인 관점 : 핵심 비즈니스 로직부가적인 관점 : 데이터베이스 연결, 로깅, 파일 입출력 등class A { method a() { AAAA method a가 하는 일들 BBBB } method b() { AAAA method b가 하는 일들 BBBB }}class B { method c() { AAAA method45 c가 하는 일들 BBBB }}여기서 여러군데서 사용되는 중복되는 코드를 aspect로 모듈화하고 핵심적인 비즈니스 로직에서 분리하여 재사용하겠다는것이 AOP의 취지AOP 용어 Target Object 부가 기능을 부여할 대상 객체를 말함 스프링에서는 주로 Service 객체가 대상이 됨 Aspect AOP 기능을 갖는 모듈 여러 객체에 공통적으로 적용되는 관심사항을 말함 스프링에서는 @Aspect 어노테이션을 달아 명시 Advice 어느 target method에 Aspect 로직을 적용할지를 명시하는 것 스프링에서는 @Around 어노테이션을 달아 명시 Pointcut 어느 target method에 Aspect 로직을 적용할지를 정의하는 표현식 스프링에서는 @Around 어노테이션 값으로 들어갈 내용 Joint Point target method의 이름, 객체 정보, 파라미터 정보 등을 가져올 수 있는 인터페이스 스프링에서는 Advice 메소드의 파라미터 객체(ProceedingJoinPoint)에 해당 weaving지정된 객체에 Aspect를 적용해 새로운 프록시 객체를 생성하는 과정A 객체에 트랜잭션 Aspect가 지정되어 있다면, A라는 객체가 실행되기전 커넥션을 오픈하고 실행이 끝나면 커넥션을 종료하는 기능이 추가된 프록시 객체가 생성되고, 이 프록시 객체가 앞으로 A 객체가 호출되는 시점에 사용된다.이때의 프록시객체가 생성되는 과정을 위빙이라고한다.Spring AOP는 런타임 시점에서 프록시 객체가 생성된다.Proxyspring AOP는 프록시 패턴이라는 디자인 패턴을 사용해서 AOP 효과를 낸다.프록시 패턴을 사용하면 어떤 기능을 추가하려 할때 기존 코드를 변경하지 않고 기능을 추가할수 있다타켓을 감싸서 타겟의 요청을 대신 받아주는 랩핑(Wrapping)오브젝트클라이언트에서 타겟을 호출하면, 타겟을 감싸고 있는 프록시가 호출되어, 타겟 메소드 실행전에 선처리, 타겟 메소드 실행 후 후처리를 실행시키도록 구성되어 있다. 프록시는 호출을 가로챈 후, 어드바이스에 등록된 기능을 수행 후 타겟 메소드를 호출한다.대표적인 스프링 AOP 예제 @Transactional : AOP 기반으로 만들어졌다. 원래 쿼리를 수행하기전에, setAutoCommit = false 쿼리 수행 후 commit or rollback 코드를 넣어준다. 비즈니스 로직에 집중할 수 있게 해주기 위해서 다양한 AOP 구현 방법 컴파일 A.java —(AOP)–&gt; A.class (AspectJ) 컴파일 시점에 특정 코드를 삽입해준다. 바이트코드 조작 A.java -&gt; A.class —(AOP)–&gt; 메모리 class loader가 클래스를 읽어와서 메모리에 올리는 시점에 (AOP)삽입한다. 프록시 패턴(스프링 AOP) " }, { "title": "Servlet, Spring MVC", "url": "/posts/servlet,-Spring-MVC/", "categories": "Spring, MVC", "tags": "Spring", "date": "2022-04-03 16:10:00 +0800", "snippet": "스프링 컨테이너자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할여기서 자바 객체를 스프링에서는 빈(Bean)이라고 부름IoC 컨테이너에 의해 관리되는 객체를 빈이라고 함IoC는 종속성 주입(DI)라고도 함스프링 컨테이너의 종류는 Bean Factory와 이를 상속한 ApplicationContext 2가지가 존재한다.Bean FactoryBean Factory는 스프링 설정파일에 등록된 Bean 객체를 생성하고 관리하는 기본적인 기능만 제공한다.컨테이너가 구동될 때 Bean 객체를 생성하는 것이 아니라 클라이언트의 요청에 의해서 Bean 객체가 사용되는 시점(Lazy Loading) 에 객체를 생성하는 방식을 사용하고 있다.일반적으로 스프링 프로젝트에서는 사용될 일이 없다.Application ContextApplication Context는 Bean Factory를 상속받고 있다.Bean Factory와 마찬가지로, Bean 객체를 생성하고 관리하는 기능을 가지고 있다.ServletDynamic Web Page를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술웹 기반의 요청에 대해 동적으로 처리해주는 역할로 Server Side에서 작동클라이언트가 요청하면 그 결과를 다시 전송해주는 역할요청 당 쓰레드 사용 CGI (Common Gateway Interface) Servlet 등장 이전에 사용하던 기술로, 요청 당 프로세스를 만들어 사용 장점 (CGI와 비교) 빠름 플랫폼 독립적 보안 이식성서블릿 컨테이너서블릿은 요청을 받거나 내보낼 때, 자신이 알아서 하는 것이 아니라 서블릿을 실행시키는 주체인 서블릿 컨테이너를 이용한다.Servlet container는 어떤 요청에 대해 어떤 Servlet을 실행할 것인지 제어즉, 서블릿이 웹 서버와 통신할 수 있도록 해준다.주요 기능 서블릿의 생명주기 관리 웹 서버와 소켓을 만들어서 통신 멀티스레딩 관리 XML을 통한 선언적인 보안 관리대표적인 서블릿 컨테이너에는 톰캣, 제티 등이 있다.Dispatcher ServletServlet Container에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 처리하기 위해 첫 번째로 실행되는 Servlet (Front Controller)공통 작업을 처리한 후 적절한 세부 컨트롤러로 작업을 위임해준다.Dispatcher가 받은 요청은 HandlerMapping으로 넘어간다.Dispatcher Servlet의 흐름장점 web.xml의 역할 축소 ⇒ 해당 애플리케이션으로 들어오는 모든 요청을 dispatcher servlet이 핸들링 @MVC 사용 가능 ⇒ MVC 패턴에 맞게끔 애플리케이션을 개발하도록 유도 단점모든 요청을 Controller로 넘겨주는 방식이 효율적으로 보이지만, 정적 파일에 대한 요청까지 Controller로 넘겨버리는 단점이 있다.문제 해결 방법 정적 자원에 대한 요청과 애플리케이션에 대한 요청을 분리 /apps 의 URL로 접근하면 Dispatcher Servlet이 담당 /resources 의 URL로 접근하면 Dispatcher Servlet이 컨트롤할 수 없으므로 담당 X ⇒ 모든 요청에 대해 위의 URL을 붙여줘야 하기 때문에 코드가 지저분해질 뿐더러 직관적인 설계가 될 수없음 애플리케이션에 대한 요청을 탐색하고 없으면 정적 자원에 대한 요청으로 처리 모든 요청을 컨트롤러에 해두고 Dispatcher Servlet에서 해당 요청에 대한 컨트롤러를 찾을 수 없는 경우, 2차적으로 설정된 resource 경로를 탐색하여 자원을 찾아냄 ⇒ 영역 분리로 인한 효율적인 resources 관리, 추후 확장 용이 Spring의 경우web.xml에서 Dispatcher Servlet 설정. 그 외의 다른 servlet도 마찬가지로 web.xml에 설정Spring Boot의 경우web.xml이 아닌 java config 사용spring boot에서는 Dispatcher Servlet이 기본으로 설정되어 있어서 설정을 하지 않아도 됨Spring MVCModel : 도메인 객체 또는 DTO로 화면에 전달할 또는 전달 받은 데이터를 담고 있는 객체View : 데이터를 보여주는 역할. HTML, JSP, thymeleafController : 사용자의 입력을 받아 모델 객체의 데이터를 변경하거나, 모델 객체를 뷰에 전달하는 역할장점 동시 다발적 개발 ⇒ 프론트, 백 독립적으로 개발 가능 높은 결합도 ⇒ 논리적으로 관련있는 기능을 하나로 묶거나, 특정 모델과 관련있는 뷰를 그룹화 할 수 있다. 낮은 의존도 ⇒ model, view, controller는 각각 독립적 개발 용이성 ⇒ 책임이 구분되어 있어 수정 용이함단점 코드 네비게이션 복잡함 코드 일관성 유지에 노력 필요 높은 학습 곡선" } ]
